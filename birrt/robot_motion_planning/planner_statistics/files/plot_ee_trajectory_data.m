% +++++Plotting the endeffector trajectory generated by the planner ++++++

%Load EE Trajectory information
ee_trajectory_data = load('../data/bi_informed_rrt_star/glass_scene_ee_trajectory_run_0.txt');

%% ------------ Position Trajectory Data ---------------
%Get Position Data
ee_pos_trajectory = ee_trajectory_data(:,1:3);


%Number of poses stored in the trajectory
num_poses = size(ee_trajectory_data,1);

%Pose number array
pose = 1:1:num_poses;

h = figure;
% X-Dimension Trajectory
ax1 = subplot(3,1,1);
plot(ax1, pose,ee_pos_trajectory(:,1),'r');
xlim(ax1,[0 num_poses]);
ylabel(ax1, 'x [m]');
title(ax1, 'End-effector Position Trajectory');
% Y-Dimension Trajectory
ax2 = subplot(3,1,2);
plot(ax2, pose,ee_pos_trajectory(:,2),'g');
xlim(ax2,[0 num_poses]);
ylabel(ax2, 'y [m]');
% Z-Dimension Trajectory
ax3 = subplot(3,1,3);
plot(ax3, pose,ee_pos_trajectory(:,3),'b');
xlim(ax3,[0 num_poses]);
xlabel(ax3, 'Pose Number');
ylabel(ax3, 'z [m]');



%% ------------ Orientation Trajectory Data ---------------
%Get Orientation/Quaternion data
ee_orient_trajectory_global = ee_trajectory_data(:,4:7);
%Change quaternion parameter order to w,x,y,z (in file it is x,y,z,w)
ee_orient_trajectory_global = [ee_orient_trajectory_global(:,4) ee_orient_trajectory_global(:,1) ee_orient_trajectory_global(:,2) ee_orient_trajectory_global(:,3)];

%Transform orientations from global frame into start end-effector frame
start_rotation_inv = quatinv(ee_orient_trajectory_global(1,:));
ee_orient_trajectory_local = zeros(num_poses,4);
for n=1:1:num_poses
    ee_orient_trajectory_local(n,:) = QuatHProd(start_rotation_inv,ee_orient_trajectory_global(n,:));
end

%Convert Quaternions into ZYX Euler Angles Convention in [rad]
[roll, pitch, yaw] = quat2angle(ee_orient_trajectory_local,'XYZ');

%Eliminate switching from 180 to -180 degrees and vice versa
% Q = unwrap(P) corrects the radian phase angles in a vector P by adding multiples of ±2π when absolute jumps between consecutive 
% elements of P are greater than or equal to the default jump tolerance of π radians. If P is a matrix, unwrap operates columnwise.
% If P is a multidimensional array, unwrap operates on the first nonsingleton dimension.
%Q = unwrap(P,tol) uses a jump tolerance tol instead of the default value, π.
%Q = unwrap(P,[],dim) unwraps along dim using the default tolerance.
%Q = unwrap(P,tol,dim) uses a jump tolerance of tol. 
roll = unwrap(roll);
pitch = unwrap(pitch);
yaw = unwrap(yaw);

%Angles in degree
roll_deg = radtodeg(roll);
pitch_deg = radtodeg(pitch);
yaw_deg = radtodeg(yaw);

%Plot
h1 = figure;
% Roll-Angle Trajectory in rad
ax4 = subplot(3,2,1);
plot(ax4, pose,roll,'r');
xlim(ax4,[0 num_poses]);
%ylim(ax6,[-3.14 3.14]);
xlabel(ax4, 'Pose Number');
ylabel(ax4, 'Roll Angle [rad]');
title(ax4, 'End-effector Orientation Trajectory');
% Roll-Angle Trajectory in degree
ax7 = subplot(3,2,2);
plot(ax7, pose,roll_deg,'r');
xlim(ax7,[0 num_poses]);
%ylim(ax7,[-180 180]);
xlabel(ax7, 'Pose Number');
ylabel(ax7, 'Roll Angle [deg]');
title(ax7, 'End-effector Orientation Trajectory');

% Pitch-Angle Trajectory in rad
ax5 = subplot(3,2,3);
plot(ax5, pose,pitch,'g');
xlim(ax5,[0 num_poses]);
%ylim(ax5,[-3.14 3.14]);
ylabel(ax5, 'Pitch Angle [rad]');
% Pitch-Angle Trajectory in degree
ax8 = subplot(3,2,4);
plot(ax8, pose,pitch_deg,'g');
xlim(ax8,[0 num_poses]);
%ylim(ax8,[-180 180]);
ylabel(ax8, 'Pitch Angle [deg]');

% Yaw-Angle Trajectory in rad
ax6 = subplot(3,2,5);
plot(ax6, pose,yaw,'b');
xlim(ax6,[0 num_poses]);
%ylim(ax6,[-3.14 3.14]);
ylabel(ax6, 'Yaw Angle [rad]');
% Yaw-Angle Trajectory in degree
ax9 = subplot(3,2,6);
plot(ax9, pose,yaw_deg,'b');
xlim(ax9,[0 num_poses]);
%ylim(ax9,[-180 180]);
ylabel(ax9, 'Yaw Angle [deg]');










